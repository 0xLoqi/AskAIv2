Backend Services (Authentication, Data, and Billing)
While most of Skai’s intelligence runs on the client (and via external AI APIs), a cloud backend will support user management and subscription services:
User Authentication: We’ll integrate a service like Firebase Authentication to handle sign-ups and logins. This provides a secure, quick way to manage user identities across devices. “Firebase Authentication lets you add an end-to-end identity solution to your app for easy user authentication, sign-in, and onboarding in just a few lines of code.”​
firebase.google.com
 Using Firebase (or similarly, Supabase Auth) means we don’t have to store passwords or build auth UIs from scratch – we can allow users to sign in with email/password, Google, Microsoft, etc. The Windows client will include a login screen (or possibly leverage web-based OAuth flows).
User Data & History Sync: With authentication, we can optionally store user conversations or settings in the cloud. For privacy, the history might default to local-only (stored in a local SQLite or JSON file). However, if a user logs in on multiple devices or reinstalling, they might appreciate syncing important threads or preferences. Using Firebase Firestore or a Supabase database, we can save conversation history (encrypted or with user consent) and settings (like the user’s name, favorite prompts, etc.). This also allows a web or mobile client in the future to share the same data.
API Keys & Calls Management: The app itself will need access to OpenAI API (for GPT-4, Whisper). We have two approaches:
Direct (client-side): The user provides their own OpenAI API key in settings. This is similar to ShotSolve’s model where “you need to bring your OpenAI API key to use ShotSolve”​
shotsolve.com
. The key would be stored securely on the user’s machine (e.g., using Windows Credential Locker, analogous to how “ShotSolve stores your API key securely in Apple Keychain”​
shotsolve.com
). API calls then go directly from client to OpenAI, and the user’s own OpenAI billing covers the cost. This approach reduces our backend complexity and cost to zero, but it’s not user-friendly for a mainstream product and limits monetization (the app would have to charge for the software itself).
Proxy (server-side): The app talks to our backend server, which then calls OpenAI’s APIs using our keys. This way, we can meter usage and bill users internally (through subscriptions or credits). The key is never exposed to the client. The backend can be a lightweight API gateway (could even use Firebase Cloud Functions or a simple Node/Python server) that accepts requests from authenticated clients, attaches the OpenAI credentials, and forwards the request. We’d need to implement rate limiting and logging to track each user’s usage against their plan.
A hybrid approach could allow both: free users must bring their key (thus self-paying OpenAI usage), whereas paid subscribers use the managed service with our key included.
Subscription Management: We plan to monetize Skai via subscriptions or usage credits (detailed in the next section). The backend will therefore need to handle payment processing and plan enforcement:
We can integrate Stripe for payments (Stripe has APIs for one-time purchases, subscriptions, etc.). For instance, when a user subscribes, Stripe Webhook can notify our server and we mark the user’s account in our database as Pro (with an expiry date or active flag).
Alternatively, if using a platform like Paddle or Microsoft Store, we’d integrate their SDK. However, Stripe gives more control. We might also use ready-made solutions for subscription handling (there are SaaS that manage it).
The app will query the backend for the user’s plan info on launch or login. Certain features (like GPT-4 access, or number of requests) will depend on the plan. E.g., a free tier might have a monthly cap or only GPT-3.5.
Telemetry and Logging: To improve the product and monitor costs, some telemetry might be sent to the backend (with user consent). For example, logging how often suggestions are shown, or if any errors occur (crash reports). We will ensure not to log sensitive content of queries unless explicitly allowed since privacy is a priority. For debugging, perhaps anonymized data or just success/failure counts suffice.
Tech stack for backend: We can use Firebase (Authentication, Firestore DB, Cloud Functions) which covers a lot with minimal maintenance. Firebase Auth is secure and scalable, and Firestore can store user profiles and subscription status easily. Another option is Supabase, which offers an open-source backend (Postgres + Auth). Supabase might be chosen if we prefer SQL and self-hosting flexibility. In either case, the backend is relatively straightforward – we’re mostly outsourcing heavy infrastructure (no need for our own GPU servers since we use OpenAI’s).