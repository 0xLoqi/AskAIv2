Authentication & User Management
Implementing a smooth authentication flow is essential for a polished experience and to enable the subscription model:
Account Creation: Users will be prompted to create an account (or log in) upon first launching the app (unless we decide to allow a “guest mode” that uses BYO API key for free use). Account creation can be via email + password or OAuth (Google, Microsoft, etc.). Using Firebase Auth, we can support both easily. For instance, a “Sign in with Google” button can redirect to Google’s auth and come back with credentials.
Session Management: Once logged in, the app receives a Firebase ID token (JWT). We’ll store this in memory (and refresh it using Firebase’s SDK when needed). The token will be sent with any backend requests to verify the user’s identity. Also, the app can remember the login (Firebase can provide refresh tokens to keep users logged in across app restarts securely).
Sync & Personalization: After login, the app fetches the user’s profile from Firestore/Supabase. This might include:
Subscription status (e.g., plan type, remaining credits if applicable).
User’s name or avatar (used for a personalized greeting or for the assistant to know the user’s name).
Any saved preferences (like if voice or vision is toggled on, or if they have some custom prompt personas).
Conversation history (if we sync chats). We might allow the user to opt-in to sync; otherwise, store history locally only.
Anonymous Mode: We should allow skipping login for those just testing (with limited functionality). But to use beyond trial, login will be required (so we can enforce any usage limits and track their data).
Auth for API Calls: If we do client-direct OpenAI calls with user API key, then auth is not needed for that functionality. But since we plan for a subscription model, we likely go with backend proxy. So the client will call our endpoint like /ask with the user’s question; it must include the user’s auth token so the backend knows who is asking (and check they are allowed). We’ll implement verification on the backend (Firebase Admin SDK can verify ID tokens easily).
Securing Keys: The app itself will have Firebase config (non-sensitive) and perhaps a public API URL. The critical OpenAI secret keys will reside only on the server. If we do allow BYO key, the user’s key will be stored on their machine as mentioned (perhaps encrypted with DPAPI). We will not store any user-provided OpenAI keys on our servers unless absolutely necessary.
Logout and Account Deletion: Provide an option to log out, and under GDPR etc., an option to delete account (which we’d handle by deleting their data from Firebase/DB on request).
Supabase Alternative: If using Supabase, the flow is similar – Supabase provides an auth API. We’d include the Supabase URL and anon key in the client (not sensitive). Supabase returns a JWT as well. Supabase might require a bit more manual handling in a desktop app environment (no built-in UI libraries for WPF, but we can pop up a WebView for OAuth if needed, or just implement our own email/password form and use Supabase REST endpoints).
Why Auth Matters: Not only for monetization, but also for features like syncing and possibly community-driven enhancements (imagine sharing a custom skill, etc. in future). It also deters abuse (if someone tried to spam our API, we can cut off their account).
Social Login Consideration: Many users appreciate the convenience of logging in with Google/Microsoft (especially since we’re on Windows, Microsoft Account login could be offered). Firebase makes that relatively straightforward to implement via OAuth redirect. We might include those options in addition to a standard email sign-up.
In summary, the authentication strategy will use a third-party managed service (Firebase) to minimize development time and security risk, providing a robust foundation for user account management. This ties in with the subscription model to differentiate free vs paid usage.